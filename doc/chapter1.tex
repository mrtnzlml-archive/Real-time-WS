\chapter{Real-time komunikace}
Real-time komunikace představuje významný prvek v aplikacích, kde je zapotřebí velmi rychlých reakcí systému. Zpravidla se za real-time aplikaci považuje systém, který řeší časové korekce posílaných signálů a tedy vzájemnou časovou synchronizaci vysílače a přijímače. Obecně lze však za real-time aplikaci uvažovat systém, který reaguje na požadavky bez zbytečného dopravního zpoždění, které je například u webových aplikací naprosto běžné. Předejít však dopravnímu zpoždění u webových aplikací není možné. Důvod je prostý. Webová aplikace musí být dostupná pro všechny uživatele na celém světě a z toho plyne, že každý uživatel je na jiném geografickém místě a čas potřebný k dostání informace ke koncovým uživatelům není stejný. Tento problém lze částečně vyřešit distribuovaným systémem, kdy se servery přibližují uživatelům, což prakticky dělají například streamovací portály jako je YouTube. Toto řešení má svá omezení a proto druhým způsobem, jak ušetřit čas při komunikaci s koncovým prvkem, je zjednodušit komunikační protokol, nebo se omezit na co nejméně zbytečné režie a to i za tu cenu, že nedojde ke stoprocentnímu přenosu informace.

\section{Hardwarové prostředky senzorické sítě}
Hardwarové prostředky této sítě nejsou v současné chvíli nijak přesně definovány. Je tedy možné síť navrhnout libovolným způsobem. Vzhledem ke komplikovanosti celé problematiky bude tato síť striktně metalická paketová. Taková síť se tedy skládá v nejmenší konfiguraci pouze z koncového členu a serveru. S narůstajícím počtem koncových členů je zapotřebí síť patřičně rozšiřovat. Výhodou tohoto systému je fakt, že se daná síť nijak neliší od běžných metalických ethernetových sítí, tzn. že lze využít veškeré dostupné prostředky pro tvorbu této sítě a není zapotřebí vyvíjet zbytečně drahá nová zařízení.

Celá síť se tak skládá z klasického ethernetového vedení a rozbočovačů, přepínačů popř. směrovačů. Zbývá tedy vyřešit server a koncové členy. Zde však záleží na praktické aplikaci. Vezmeme-li však v úvahu nejobyčejnější systém, server pak může být prakticky jakýkoliv počítač, který dokáže zpracovat příchozí požadavky. Tzn. musí být dostatečně výkonný a pro lepší bezpečnost celého systému také redundantní (nebo alespoň některé kritické komponenty v něm). Redundanci komponent však dobře řeší klasické servery, kde jsou redundantní například zdroj, pevné disky, řadiče a dále duální paměti popř. procesory.

Samotné koncové prvky se pak sestávají z nízkoodběrových procesorů, které mají menší, pro danou aplikaci však dostatečný výkon. Zde opět záleží na daném účelu koncového zařízení. Pokud má sloužit jako koncentrátor, tedy zařízení sbírající data ze senzorů, potřebuje větší výkon než například termální čidlo. Výkon koncového prvku je tak dán samotným programem, který na tomto prvku poběží.

Tato síť je tedy v takovém stavu, kdy je zapojen server (nejlépe na nezávislém napájení) a senzory jsou zapojeny v ethernetové síti pomocí běžných síťových prvků. Důležité je však vyřešit co se stane, když vypadne napájení? V tomto okamžiku síť prakticky přestane fungovat. Toto se nijak neliší od např. běžné zapojení elektroinstalace. Sice by šlo zajistit napájení koncových prvků, protože server může být zapojen na více nezávislých zdrojích elektrické energie, to však nebude např. v rodinném domě běžné. Horší případ nastane, když vypadne připojení k internetu. Zde by se nejednalo o problém, pokud by se server nacházel v řízeném objektu. Jediný efekt by byl ten, že by nebylo možné server ovládat vzdáleně. Horší situace ovšem nastane v okamžiku, kdy je server umístěn ve vzdálené serverovně. V takovém případě je pro tuto senzorickou síť potřeba vyřešit tzv. disaster solution, tedy nějaký fallback zařízení při selhání. Samotné koncové členy musí vědět jak se chovat bez příchozího signálu. To většinou není problém, protože paradoxně není potřeba řešit jejich chování. To je nutné pouze v případě zabezpečení objektů. Starostí koncových členů totiž není např. vypnout světlo, pokud není systém připojen k internetu. V takovém objektu je však zapotřebí zařadit do sítě zařízení, které bude přijímat od serveru povely a obsluhovat síť. V případě přerušení spojení se serverem převezme toto zařízení kontrolu nad sítí a uvede objekt do dočasného módu, než se problém vyřeší, nebo než přijede servis. Bude tak možné i nadále ovládat alespoň na základní úrovni většinu zařízení.

\section{Real-time ve webových aplikacích}
Ve webových aplikacích žádný real-time jako takový v podstatě neexistuje. Existují však technologie, které umožňují rychlou komunikaci s webovým serverem, resp. rychlou výměnu dat, což vždy nemusí být jedno a to samé.

Jedním z typických zástupců je AJAX (popř. AJAJ). Jedná se jednosměrný mechanismus, kdy se po periodické akci, nebo například při stisku tlačítka vyvolá javascriptová akce, která uzavře HTTP spojení se serverem a získá data v závislosti na požadavku. Následně překreslí část stránky obsahující nová data. Nedojde tak k obnovení celé stránky, ke kterému by došlo při běžném pohybu návštěvníka na stránce. Výhodou je, že není zapotřebí přenášet celou stránku. Nevýhodou však je možný nárůst HTTP požadavků na server a hlavně nutnost vyjednat se serverem spojení při každém požadavku, což je časově velmi náročné. Pro tuto aplikaci je proto použití AJAXu nevhodné.

Oproti tomu websocket \cite{rfc6455} je protokol, který umožňuje otevřít socket mezi serverem a prohlížečem a pomocí rámců posílat obousměrně informace. Vyjednat spojení se serverem tak stačí pouze jednou při otevření webové stránky a následně je možné velmi rychle se stránkou komunikovat. Zároveň se periodicky kontroluje, jestli je stránka stále aktivní (tzv. heartbeat) a pokud ne, server spojení uzavře. Nespornou výhodou je také fakt, že websocket využívá principu event-driven, takže kromě periodické kontroly aktivního spojení je možné posílat data pouze pokud je to nutné, což hodně ušetří na komunikaci mezi serverem a browserem. Websocket staví nad HTTP, takže mu dnešní prohlížeče rozumí, nicméně pro případ toho, že by webovou stránku otevřel uživatel ve starším prohlížeči, jsou většinou k dispozici fallback řešení ve formě jiných technologií tak, aby stránka fungovala. V tomto případě se jedná zejména o XHR-polling a JSONP-polling.

\section{TCP}
Protokol TCP je jedním ze dvou transportních protokolů \cite{mistrovstvi}, které tento systém využívá. Stejně tak jako UDP je zde tento protokol rozbírán zejména z toho důvodu, že právě na TCP packetech a UDP datagramech je vystavěna komunikace mezi koncentrátory a serverem. Oproti UDP protokolu se jedná o poměrně komplikovanou a tedy i časově náročnou komunikaci. Posloupnost komunikace je následující, přičemž na adrese \texttt{192.168.0.20} se  nachází server:

\begin{minted}[linenos,breaklines]{text}
192.168.0.11 -> 192.168.0.20 : SYN
192.168.0.11 <- 192.168.0.20 : SYN, ACK
192.168.0.11 -> 192.168.0.20 : ACK
\end{minted}

Spojení tedy probíhá zhruba následovně. Koncentrátor (\texttt{192.168.0.11}) otevírá TCP spojení vysláním požadavku na synchronizaci příznakem \texttt{SYN}. Server potvrzuje spojení pomocí příznaku \texttt{ACK} a vysílá také požadavek na synchronizaci (\texttt{SYN}). Koncentrátor toto spojení přijímá pomocí \texttt{ACK} příznaku, čímž je spojení ustanoveno. Tomuto procesu se říká three-way handshake \cite{mistrovstvi}. Samotné poslání jednoho paketu včetně dat a uzavření spojení pak vypadá následovně:

\begin{minted}[linenos,breaklines,mathescape]{text}
192.168.0.11 -> 192.168.0.20 : SYN
192.168.0.11 <- 192.168.0.20 : SYN, ACK
192.168.0.11 -> 192.168.0.20 : PSH, ACK
192.168.0.11 <- 192.168.0.20 : FIN, ACK
192.168.0.11 -> 192.168.0.20 : FIN, ACK
192.168.0.11 <- 192.168.0.20 : ACK
\end{minted}

Začátek spojení (three-way handshake) zůstává stejný, ale pro úsporu množství přenášených informací se hned při potvrzení spojení pomocí \texttt{ACK} posílají na server data (\texttt{PSH}). Následně server uzavírá spojení a potvrzuje přijetí dat (\texttt{FIN, ACK}), koncentrátor uzavírá spojení a potvrzuje uzavření spojení serverem (\texttt{FIN, ACK}) a nakonec server potvrzuje uzavření spojení ze strany koncentrátoru (\texttt{ACK}). Je tedy zřejmé, že i po \texttt{FIN} příznaku dochází k další komunikaci. Nutně tedy tento příznak neznamená úplný konec spojení, ale pouze konec z jedné strany. V tomto případě uzavírá spojení server, ačkoliv spojení nezačínal. Je to vhodné z toho důvodu, že se ušetří jedna cesta pro potvrzení dat na straně serveru a následné ukončení ze strany koncentrátoru. Navíc server by se měl v dané síti chovat velmi zodpovědně, takže nepřipouští otevřená spojení, když k tomu není důvod. V současné chvíli nejsou mezi serverem a koncentrátorem implementovány perzistentní sockety.

Nespornou výhodou TCP je fakt, že tento protokol zajišťuje to, že daný packet dorazí na cílovou adresu. To například u UDP neplatí. TCP se proto používá pro přenos kritických informací (například vypnutí/zapnutí světla). Jsou to operace, které se musí bezpodmínečně vykonat a jejich nevykonání by vedlo k velmi zvláštnímu chování sítě ze strany uživatele.

\begin{figure}[H]
    \centering
	\makebox[\textwidth]{\includegraphics[width=\textwidth]{img/tcp2.png}}
	\caption{Uspořádání TCP packetu}
	\label{fig:tcp-packet}
\end{figure}

%\begin{figure}[H]
%   \centering
%	\makebox[\textwidth]{\includegraphics[width=\textwidth]{img/tcp.png}}
%	\caption{TCP stavový diagram}
%	\url{http://commons.wikimedia.org/wiki/File:Tcp_state_diagram_fixed_new.svg}
%	\label{fig:tcp}
%\end{figure}

\section{UDP}
UDP je oproti TCP protokol typu \uv{fire and forget}. Nestará se tedy o to, jestli informace dorazila na místo určení. To má za následek určitou nespolehlivost přenosu informace, ale o mnohem méně režie potřebné pro přenos. V porovnání s TCP je tento datagram velmi malý:

\begin{figure}[H]
    \centering
	\makebox[\textwidth]{\includegraphics[width=\textwidth]{img/udp.png}}
	\caption{Uspořádání UDP datagramu}
	\label{fig:tcp-packet}
\end{figure}

Pro poslání informace potom stačí vyslat jeden tento datagram s daty a to je vše. Proto skutečnost, že neznáme výsledek přenosu vede k tomu, že musíme být smířeni s faktem, že se některé datagramy jednoduše ztratí. Tento přenos je tedy vhodný pro přenos velkého množství informací s tím, že nám případné ztráty nevadí. Typickým zástupcem toho typu přenosu jsou například kontinuální čidla, která neustále snímají (například teplotu) a v krátkých časových intervalech emitují informace.